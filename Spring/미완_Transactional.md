# 트랜잭션
데이터베이스의 상태를 변화시키기 위해 수행 작업 단위

> EX) 사용자 A 가 사용자 B에게 만원을 송금한다
>
> 1. 사용자 A의 계좌에서 만원을 차감한다 : UPDATE문
> 2. 사용자 B의 계좌에 만원을 추가한다 : UPDATE문
>
> 작업 단위 : 출금 UPDATE문 + 입금 UPDATE문 -> 트랜잭션
> 두 쿼리문이 모두 성공적으로 완료되어야만 'Comit'
> 
> 작업 단위에 속하는 쿼리 중 하나라도 실패하면 모든 쿼리문을 취소하고 이전 상태로 'Rollback'

### 트랜잭션의 특징 ACID
* 원자성(Atomicity) - 트랙잭션이 DB에 모두 반영되거나, 모두 반영되지 않아야 한다.
* 일관성(Consistency) - 트랜잭션의 작업 처리 결과는 항상 일관성이 있어야 한다.
* 독립성(Isolation) - 둘 이상의 트랜잭션이 동시에 병행 실행되고 있을 때, 어떤 트랜잭션도 다른 트랜잭션연산에 끼어들 수 없다.
* 지속성(Durability) - 트랜잭션이 성공적으로 완료되었으면, 결과는 영구적으로 반영되어야 한다.

# @Transactional 어노테이션
클래스나 메서드에 붙여줄 경우, 해당 범위 내 메서드가 트랜잭션이 되도록 보장해준다.

spring이 메서드에 대한 프록시를 만들기 때문에 CGLIB가 아닌 AOP방식의 프록시 패턴이 적용되는건가?

Test에서의 @Transactional은 자동 롤백 -> org.springframework.test.context.transaction.TestTransaction 은  @Transactional 이 적용된 테스트 메서드를 감싸고 있는 트랜잭션과 상호 작용할 수 있는 기능을 가지는 유틸리티 클래스

! id는 롤백되지 않는다. Auto Increment는 트랜잭션 범위 밖에서 동작

-> 동시성 때문에 트랜잭션 성공 여부 기다리기 힘들기 때문에 바로 부여한다는데 ?
