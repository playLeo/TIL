Stateful 프로토콜과 Stateless 프로토콜 모두 웹 서버와 브라우저의 통신을 위한 네트워크 프로토콜이다.

두 프로토콜의 차이는 서버 사이드에서 세션 및 세부 정보에 대한 추적 및 저장을 하는지에서 발생한다.


## Stateful (상태유지)
클라이언트-서버 관계에서 서버가 클라이언트의 상태를 보존한다.

클라이언트의 이전 요청이 서버에 잘 전달되었을 때, 클라이언트의 다음 요청이 이전 요청과 관계가 이어지는 것을 의미한다.
* 상태에 대해 저장해야하기 때문에 백업 스토리지가 요구된다.
* 상태 저장에 대한 요청은 서버 측 상태에 따라 달라지게 된다.
  * 서버A와 통신하던 중, 서버A 가 장애가 나면 상태정보가 날아간다.
* 대표적인 stateful 프로토콜인 TCP 프로토콜은 서버가 클라이언트와 통신 상태를 계속 추적하기 때문에 클라이언트의 세션 정보를 저장한다.





## 무상태 프로토콜 - Stateless
클라이언트-서버 관계에서 서버가 클라이언트의 상태를 보존하지 않는다.

* 서버 설계를 단순화할 수 있고, 확장성 역시 더 높다.
* 서버 확장성이 높지만(스케일 아웃), 클라이언트가 추가 데이터를 전송해야 한다.
* 대표적인 stateless 프로토콜은 HTTP가 있다.


무상태로 설계가능하면 무상태로 설계하고, 상태를 유지해야 한다면 최소한의 상태만 유지 해야한다.

일반적으로 브라우저 쿠키와 서버 세션등을 사용해서 상태를 유지한다.


||Stateless|Stateful|
|----|---|---|
|정의|	클라이언트가 서버로 요청을 보내고, 주어진 상태에 따라 서버의 응답을 다시 보내주는 네트워크 프로토콜|클라이언트가 서버에 요청을 보냈을 때, 어떤 종류의 응답을 기대하고 만약 응답이 없을 경우에는 다시 요청을 보내는 네트워크 프로토콜|
|예|HTTP|FTP(파일 전송 프로토콜), TCP|
|서버 제한|서버 정보나 세션의 세부 정보를 자체적으로 유지하고자 할때 서버가 필요하지 않다.|현재의 상태와 세션 정보를 유지하기 위해서서버가 필요하다.|
|의존성|서버와 클라이언트가 느슨한 결합으로 이루어져 있기 때문에, 서로 독립적으로 작동할 수 있다.|상태 저장이 필요하므로 서버와 클라이언트가 밀접하게 연결될 수 밖에 없다.|
|디자인|서버 설계가 구현하기에 간단하다.|설계 디자인이 복잡하고, 구현하기도 상대적으로 더 어렵다.|
|충돌 관리|서버 장애가 발생했더라도, 출돌 후 다시 쉽게 시작이 가능하다.|서버가 세션 및 여러 세부 정보들을 유지해야 하기 때문에, 충돌 관리가 더 어렵다.|
|트랜잭션|서버에서 트랜잭션을 빠르게 처리할 수 있다.|서버가 비교적 느리게 작동한다.|



## Connectionless (비연결성)
비연결성은 클라이언트와 서버가 한 번 연결을 맺은 후, 클라이언트 요청에 대해 서버가 응답을 마치면 맺었던 연결을 끊는 성질을 말한다.(HTTP 1.0초기)

**장점**
응답을 마친 클라이언트와 연결을 끊으면서 다른 클라이언트와 연결을 유지하기 위한 리소스를 확보할 수 있다.

**단점**
서버는 클라이언트를 기억하기 있지 않으므로 동일한 클라이언트의 모든 요청에 대해 매번 새로운 연결을 맺어 오버헤드가 발생한다.

TCP/IP 연결을 맺어야 하기 때문에 3 way handshake 시간이 계속 추가된다.

**극복**
HTTP 지속연결(Persistent Connection)로 문제를 해결했다.(keep-alive)

지정된 시간동안 서버와 클라이언트 사이에서 패킷 교환이 없을 경우, 상대방의 안부를 묻기위해 패킷을 주기적으로 보내고, 패킷에 반응이 없으면 접속을 끊는다.

